# 引言

- PoW
- PoS
- DPos

# chap1 密码学及加密货币概述

- 区块的组织结构
  - 每个block header有80B
  - Merkle根
- 交易 transaction
  - 花钱的时候用私钥签名
  - 小费
  - ==数字签名验证算法==？？
- 时间标签服务
  - 确定交易的先后
  - 根据区块的高度确定先后次序？？
- 工作量证明
  - 挖出区块有毕业币奖励
  - 指找出nonce
- 系统参数
  - H()=SHA256(SHA256())
  - 选一个门限值（代表挖矿难度，要保证比特币出块的难度是一定的，平均10分钟出一块
- 交易
  - 签名算法(sk,pk)
  - 哈希指针连接区块
- 交易验证：最长的区块链
- 诚实大多数原则：攻击者除非构造新链条，使得长度超越旧链条；这要求掌握超过半数的算力，是不可能的
- 密码学内容：
  - 哈希函数
    - collision-resistance
      - 难以构造出碰撞
      - 可以做message-digest，保证信息是没有经过篡改的
    - hiding
      - 哈希函数的单向性
      - 只看哈希的结果不足以找出原象
      - commit(msg,nonce) & verify(com,msg,nonce)
      - 这样的话，你提交了com之后，别人无法从com中求得msg，你也不能改变msg，因为你很难构造出这样一个msg，使得既符合verify又能表达你的意思
    - puzzle-friendliness
  - SHA-256
  - Merkle tree
    - 父节点的hash值是孩子节点算出来的。
    - 想要知道一个数据块是不是被根节点覆盖，只要一步步上推到根即可，复杂度是o(logn)
    - 哈希指针
      - 可以验证是否被篡改了
      - 区块链是通过Hash指针创造一个链表
    - 防篡改日志
    - 成员证明PoM，迅速找出是不是在分布式账本里
    - PoNonmembership
  - 公钥
    - 数字证书 RSA
    - 椭圆曲线数字签名ECC,ECDSA要保证随机性的良好来源。
    - generateKeys产生一对公钥和私钥，私钥用来签名，公钥公开，可以用来验证签名
    - sk+message就是前面
    - 用公钥、信息和签名能验证究竟是不是你发的。
      - 签名是不可以伪造的
  - 公钥及身份
    - 身份=地址=公钥的hash
    - 你的身份是hash(PK)
- 两种简单的加密货币
  - goofy
    - 任何人都可以追根溯源来验证一个货币的有效性
    - 只有goofy可以创建新的币
    - 所有人可以签署声明来转账
    - 缺点是：双重支付没解决，而且其实是中心化的
  - scroogeCoin
    - 解决了double spending
    - 财奴会给最后一个哈希指针签名，确保不会双花
    - 分为造币交易和花钱交易，在花钱的时候是把钱销毁掉再生成
    - 交易有效的条件
      - 被消耗的货币是有效的
      - 不是双花
      - 本次交易产生的钱等于小号的钱
      - 消耗的所有货币都有有效签名
    - 优点：引入了ledger来防止双重支付
    - 缺点是：财奴本人

# chap2 比特币如何去中心化

- 财奴币带来了中心化的问题
- 分布式共识
  - 提议-共识：正当的交易可以等下一次被打进区块的机会；有效的交易希望被迅速写进区块链
  - 挑战：节点会宕机，p2p通信是不完美的，信息传递的延迟
  - 不可能性结论
    - 将军有n个，n里面t个人背叛了，只要n>3t就可以容错
    - 只要三个人里有一个是叛徒，就无法判断谁是叛徒，所以要大于三，不可以等于。
  - 比特币奖励
    - 随着时间的推移，观点分歧的概率会指数下降。
- 每一个回合，一个随机的节点被选中来提议下一个区块，其他节点通过接龙来隐形地接受或者拒绝
  - 节点把那个区块的哈希包含在自己的下一个块里，这是一种接受的表示。如果你挖了错的块，你其实是浪费了算力的
- 攻击
  - 伪造数字签名窃取比特币
  - 拒绝服务攻击，A转账之后，B说没收到，其他节点都能知道B不要脸，因为B收钱的时候得提供自己的签名和公钥
  - 双花
    - 得看--哪个区块被纳入长期的共识链，所以需要等待一段时间才行
    - 技术上来看，两笔交易都是规范和形式上有效的
- 诚实大多数原理
  - 6次确认之后基本不会被覆盖，在z=6的时候，攻击成功的概率下降到0.0002428
  - 给诚实的节点奖励
    - 区块奖励只有在区块被纳入长期共识链的时候才兑现
    - 总的区块奖励是2100万比特币，迟早会分完的，到时候就得靠消费
- 如何随机选取节点
- Sybil Attack: 创建大量的女巫节点来尝试颠覆整个共识过程
- 工作量证明：是算力的竞争，比特币是求解Nonce，如果一个节点发现一个Nonce就可以提议创建下一个区块
- 每两个星期，2016个区块，目标区域的难度会调整一次，调整到10分钟出一个块。
  - 根据之前2016个区块的平均出块时间，来确定这个地方的难度是太高了还是太低了，调整难度，我们希望平均出块时间是t
- 拥有比特币就是，其他的节点承认你有。

# chap3 比特币的运行机制

- 比特币用的是公开账本
  - 因为是分布式的网络，所以是延时确认的，无法给每个账户加一个余额
  - 只记录transaction，借鉴了财奴币的记账方式
- UTXO模型 Unspent Transaction Output
- 公钥及身份
- 比特币脚本
  - 通过某人的签名获得其资金
  - 把输入脚本和输出脚本串联起来，成功执行之后，获得资金
  - 不是图灵完备的语言
  - 可以随意为比特币的支付设定条件 
  - Pay to Script Hash：支付给脚本的哈希值，收款方只要告诉付款方一个哈希值；P2SH的输出脚本很小，复杂的是输入脚本
- 第三方支付交易
  - Multisig
  - 绿色地址，银行；不是比特币的保障，而是银行用声誉来保障不会双花
  - 高效小额支付：锁定时间。等待t时间后才把退款交易计入，如果过了t时间bob还没有在最后一个交易签名，Alice可以通过退款交易收回所有的Bitcoin
- 应用：智能合约
- 把好多交易放在一个区块里，可以得到更短的哈希链，
- 区块链结合了区块的哈希链和Merkle Tree
  - ==草，原来是区块之间哈希链，区块内Merkle Tree==
- 发起一个交易：泛洪算法，gossip协议：区块越小越有利于传播，脚本简洁为要，有利于传播可以在少数时间传播到更多的节点
- 哪一个交易被纳入区块链产生分歧的时候：每个节点默认保留最早接到的交易；所以节点接收那个完全取决于它在网络中的位置
- 核验一个区块要确认里面的每一个交易
- 全节点需要存储完整的共识区块链
- 轻量节点：简单付款的节点，只存储自己关心的，即使MB数据即可
- 比特币的交易大概是7笔/s，10分钟4000笔交易
- 修订协议
  - 硬分叉：引入新特性，前一版本的协议失效
  - 软分叉：加入新特性，核验规则更严格，老的节点接收所有区块，**新的节点拒绝向下兼容**
- coinbase：铸币交易

# chap4 如何存储和使用比特币

- 存储方式
  - 冷存储，不连入互联网，锁起来。
  - 热存储，个人电脑或者手机
- 分层确定性钱包
  - 开头交换信息，冷热两端维持同步的计数器，就可以分别生成正确的公私钥。（冷存储一次性生成很多地址然后交换地址，这不好的地方在于可能会泄漏。)
- 密钥分存和密钥共享
  - 不可以直接切分
  - 我们希望，密钥被分为N个片段，如果知道其中的K个，那么就可以还原密钥，如果小于K个，那么我们无法知道密钥的任何信息。
  - n>3, k=2，那么两点确定一直线（草，好机智），直线与y轴的交点就是(0,S)，S是密钥
  - n>=3, k=3, 三点确定一个抛物线，S是在纵轴上的截距。
- 在线钱包和交易所
  - 钱包信息储存在云端
- 数字货币交易所
  - 银行把钱用于投资
  - 在银行交易之后，不是立刻会在区块链改变的
  - 不是去中心化的
    - 挤兑的问题
  - 解决
    - 最低准备金
      - 如何证明？公开Merkle tree
      - 每个用户可以向交易所所要存款证明
  - 客户用数字货币购物，商户立刻收到美元，支付的服务商获得手续费：服务商承担了风险。---汇率风险
- base64->base58
- 确认你的交易需要代价，所以你需要给交易费

# chap5 比特币挖矿

- 矿池

  - 单个矿工有挖矿风险
  - 对于小矿工而言，挖矿是赌博，但是矿池是比特币矿工相互的保险
  - 不是平分而是照工分多少来分
  - 分红方案：管理员承担了风险
  - 按比例分红
  - 投机矿工：早期加入按照实际比例分红的矿池，后期到一个按照工分分红的矿池——解决办法：根据最近若干个工分提交的结果才分配分红
  - 缺点是：中心化管理。

- 选择交易费高的交易

- 在最长的链条上向下挖

- 同一高度的话，挖最先监听到的那个

- 挖到立刻宣布

- 缺点：中心化管理

- CPU->GPU->FPGA（经常报错）->ASIC->挖矿中心

- 监听交易广播，维护区块链网络、监听新的区块、组装备选区块、找到有效的随机数、希望区块被全网接收、利润

  - 选出有效的交易构建merkle tree

  - 挖矿从nonce=0开始，一直++，直到区块有效为止。nonce是32bit

    - 如果遍历Nonce的取值空间还没找到有效区块的时候，改动coinbase中的随机数。

      ![image-20211227203212779](C:/Users/16834/Desktop/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AC%94%E8%AE%B0/image-20211227203212779.png)

    - 也就是说coinbase+nonce才能挖到一个矿

    - 挖到了立刻宣布

    - 难度的调整，每2016个块，2week调整一次

- 攻击：中心化的攻击者快速通信从而节省算力

- 区块奖励在矿工收入里面占比超过99%

# chap6 比特币和匿名性

- 混币，无法建立输入和输出的匹配关系
- 零知识证明ZKP，证明自己有但是不泄漏知识
- 

# chap8 其他挖矿算法

以太坊和智能合约

- 其编程语言solidity是图灵完备的
- 智能合约是**存储在区块链上的程序**，由各个节点运行，运行程序的人需要给节点的矿工支付手续费，被一个虚拟机运行EVM
- token代币：智能合约可以创造代币。
- 权益证明，poS，比poW更有效率，节省挖矿的电脑资源，避免网络中心化
- 燃料：用资源要交燃料费，通过gas来限制计算和存储资源。
- 以太坊上的分布式应用程序不会被停机，也不能被关掉。
- uncle block：把速度比较慢而未及时收入母链的较短区块链并在一起，提高交易量，有向无环图。

# chap10

- merkle tree
- 区块链的特点、准时出块10分钟
  - 去中心化
  - 全球流通
  - 匿名性
  - 公开透明
  - 不可篡改
  - 可追溯性
  - 自治性
- double spending attack
  - 解决双花的核心在于确认这笔交易在之前从未发起过，明确时间顺序
- 工作量证明：逐次修改区块中的Nonce直到满足要求
- 

# 总结

- 我的笔记 ok

- ppt ok

- 代码，稍微看了

  ```
  <sig><publickey> OP_DUP OP_SHA256 <publickeyhash> OP_EQUALIFICATION OP_CHECKSIG
  ```

- 书面作业，等待王文蕊
